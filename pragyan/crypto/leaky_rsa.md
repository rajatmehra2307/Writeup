### Problem description

In this challenge we were given two files, ```cipher.txt``` and ```keys.txt```. The file ```keys.txt``` had the following content
```
n=90622785163120637260087015941572725098110139248382612878945571071101519512487568042232671567664172893228075756497045498977699900942323326164843993553269528291618632246672608219867461615864060915805942735237995404948413293503561184020274098566470196075252508233670564868845603564225996537006792676270111655183
e=65537
d=15881146338685635884036488977050563006420723396976888000895522891673420382393452842898549414141981257590741871971078437459128177400896949829916432945653604999697231535449287553706229377750925398422163407130833254874911822837377080596876193928404120093555522404504384602474224038479487948631716643357270128113
```
and the problem was to figure out the two primes p, q for n and xor these p and q to come up with a key and xor that with the cipher in ```cipher.txt```. 

### Approach 

In order to figure out p, q using the private key d, we can use the attack presented in Boneh's paper http://www.ams.org/notices/199902/boneh.pdf , the idea is to compute k = ed - 1 and use a random g to compute g^{k/2}, g^{k/4} etc until one of them is a non trivial square root of unity mod N.

After decrypting the text in ```cipher.txt```, we get the following output:
```
Looks like someone mutiplied "password" with the flag before encrypting.
message=0b100010111110011111010011001110001111000010000100000111100100101100111110011110001010000111010100110000101001000111011100010000010111110010011001001111111111101110000111110111110010110010010000111000110011000010010100010000111100111010100010111100111111101100001111000100101001001000001111010111111101110011010011111111111010011010101100001011001000110101110010010101110011001000010111101100110101110101001001110111110010111110000101110000000110010110110110001111110110111100011000100101100101001001001011010101101000000010011111011110000001101100110000101001011101001011100111111101101111100111110101001010111001001011001100101101110110101010011011011110010000100011111111100010001101000101110000100110000000110110001001100000111011111101011011011000000101010110100011101011000001000000100010100000011000010000011001001110001011000101100110011000001110110010010000011110001110111000001100010011111110111101100111111010100011000011001110010000000000100111010010000011101100000001001110010100001100011010001011101110001001111
```
We get another encrypted number but this time it says the flag was multiplied by the string "password" before encrypting. This was an RSA encryption of flag multiplied by "password". On decrypting this with the private RSA exponent given in ```keys.txt```, and dividing by "password", we get the flag
```
p_ctf{0n3_1eak_15_en0u6h_70_4774ck_rsa}

```

### Exploit

```
from math import gcd
from pwn import *
from random import randrange
from math import gcd

def convert_priv_to_factor(n, e, d):
	k = d * e - 1
	t = k.bit_length()
	trivial_sqrt1 = {1, n - 1}
	while True:
		g = randrange(2, n - 1)
		for j in range(1, t + 1):
			x = pow(g, k >> j, n)
			if pow(x, 2, n) == 1:
				if x in trivial_sqrt1: continue
				p = gcd(x - 1, n)
				q = n // p
				return (p, q)

cipher = "03cbfb27971838e83245ff0ee4340491f81319c9c5122289f287c6439946de361e5b5a40bb25798ed0139a172f1003e0f4fd663ac2469b9706b29c267add203d3ddde4388d5633af534dba0ef838069bab465b9580567bc8aedf921688559e675c191c1ef8716a9e974bdf4f3f555ab4e4ab3a6a9457c8c250edde726a887e6e7e94a47cd40865b06811ef4dba6951cfa647089480577ac8afdf931788559f665d181d1ef9706b9e974adf4e3e545ab5e5ab3a6a9456c9c250ecde726a887f6e7f94a57dd50865b06810ef4dba6951cea646089481577ac8afde931689549f665d181c1ff9706a9f964bdf4e3e555ab4e4aa3b6a9556c9c251ecdf726b887f6f7e95a57cd40964b06810ef4cbb6950cea646099581577bc9aedf921789559f675d181d1ef9716a9e964ade4f3e545bb5e4aa3b6a9456c9c351ecde726a897e6e7f95a47dd50965b16911ee4cba6850cfa647089480567bc8afdf921789549f675d191d1ef9716a9e974bde4f3f545bb4e5aa3b6b9456c8c351ecdf726b887f6f7e94a47dd50865b16911ee4cba6850cfa747089580577bc9afdf931689559e665c181d1ff9706b9f964ade4e3f545bb4e5ab3b6b9457c8c250ecde736b887f6e7e95a57cd40965b16911ef4dbb6950cea747089580577ac9aedf921788549f665c181c1ff8716b9f974adf4e3e545ab4e5aa3b6b9557c9c351ecdf726a887e6e7e94a57dd50864b16910ef4dba6851cea746089580577ac9afdf931789559f665c191c1ff8706b9f964bdf4f3f545ab4e4ab3a6a9556c8c251ecde736b887f6e7f95a47cd50864b06911ee4dba6950cea747099580567bc9aede931689549f665c191c1ff8706a9f974ade4f3f545ab4e4aa3b6b9557c8c250edde726a897e6e7e94a57dd50865b16911ef4cba6851cea747089581577ac9afdf931688559f665d181c1ef8706a9e964adf4f3f555bb4e4aa3b6a9556c8c250ecde726b887e6f7e94a47dd40965b16811ee4dba6851cfa647099580567ac8aedf921788559f665d181c1ff9716b9f974ade4e3e555ab4e5aa3b6a9556c9c350edde726b887f6e7f94a57cd50965b16910ef4cbb6950cfa646099480567bc8afde921689549e665d181c1ef9716b9e974bdf4e3f555ab4e5aa3b6b9456c8c350ecdf736b897e6e7f94a47cd50865b16810ee4cbb6851cea647089580577bc8afde931789549f675d181d1ff9706b9e974bde4e3f545bb5e4ab3b6a9556c9c251edde736a887f6f7f94a57cd40965b06910ef4cbb6850cea646089481577bc9afdf931788559e675d181d1ef8706b9f964ade4e3f545ab5e4ab3a6b9457c8c350edde726b897e6f7e95a47cd40864b06810ef4dba6951cfa747089581577bc8afdf921788559e675c191c1ef8706b9f974bde4f3f555ab5e4ab3a6a9456c9c351ecde736b887e6e7f94a47cd40864b06910ee4cba6950cea647099480567bc8afdf931688549e675d181d1ff8716b9f964bde4f3e545ab5e4ab3a6a9456c9c251ecde726a887e6f7f95a57dd40965b06910ef4cbb6950cfa747"


with open("keys.txt", "r") as f:
	n = int(f.readline()[2:], 10)
	e = int(f.readline()[2:], 10)
	d = int(f.readline()[2:], 10)

(p, q) = convert_priv_to_factor(n, e, d)


key = p ^ q

cipher_bytes = bytes.fromhex(cipher)
key_bytes = bytes.fromhex(hex(key)[2:])
def encrypt(var, key):
    return bytes(a ^ b for a, b in zip(var, key))

ans = b''

for i in range(20):
	block = cipher_bytes[i*len(key_bytes): (i+1)*len(key_bytes)]
	ans += encrypt(block, key_bytes)

ans = ans.decode()
print(ans)

new_cipher = 0b100010111110011111010011001110001111000010000100000111100100101100111110011110001010000111010100110000101001000111011100010000010111110010011001001111111111101110000111110111110010110010010000111000110011000010010100010000111100111010100010111100111111101100001111000100101001001000001111010111111101110011010011111111111010011010101100001011001000110101110010010101110011001000010111101100110101110101001001110111110010111110000101110000000110010110110110001111110110111100011000100101100101001001001011010101101000000010011111011110000001101100110000101001011101001011100111111101101111100111110101001010111001001011001100101101110110101010011011011110010000100011111111100010001101000101110000100110000000110110001001100000111011111101011011011000000101010110100011101011000001000000100010100000011000010000011001001110001011000101100110011000001110110010010000011110001110111000001100010011111110111101100111111010100011000011001110010000000000100111010010000011101100000001001110010100001100011010001011101110001001111


n = p*q

m = pow(new_cipher, d, n)

password = b'password'

num = int.from_bytes(password, 'big')

print(bytes.fromhex(hex(m//num)[2:]).decode())


```